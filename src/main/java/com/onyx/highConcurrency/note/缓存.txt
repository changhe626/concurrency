缓存特征:
命中率: 命中数/(命中数+没有命中数)
最大元素(空间)
清空策略:FIFO,LFU,LRU,过期时间,随机等


缓存命中率影响因素:
业务场景和业务需求
缓存设计(粒度和策略)
缓存熔炼个基础设施

缓存分类和应用场景:
本地缓存:缓存实现(成员变量,局部变量,静态变量),Guava Cache,Ecache
分布式缓存:Memcache,Redis

Guava Cache:
封装在WeakMashMap中

高并发的时候缓存问题:
缓存一致性:
更新数据库成功->更新缓存失败->数据不一致
更新缓存成功->更新数据库失败->数据不一致
更新数据库成功->淘汰缓存失败->数据不一致
淘汰缓存成功->更新数据库失败->查询缓存miss


缓存并发问题:


缓存穿透问题:

    缓存空对象
    缓存单对象
    缓存数据时效性
    单独过滤处理

缓存雪崩现象:


股票分时线中缓存的使用:

用guava  cache 缓存最近几分钟的数据,以股票的id为key,
启动线程将数据写到redis中去.

缓存的清空和失效策略.很少涉及到数据库,基本都是操作缓存.



https://juejin.im/entry/57e39e320e3dd90058021bff
https://segmentfault.com/a/1190000015000722


分布式缓存的常见问题和挑战
1.缓存雪崩

缓存雪崩我们可以简单的理解为：由于原有缓存失效，新缓存未到期间(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，
所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。

2.缓存穿透

缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，
然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。

3.缓存预热

缓存预热这个应该是一个比较常见的概念，相信很多小伙伴都应该可以很容易的理解，缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。
这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！

4.缓存更新

除了缓存服务器自带的缓存失效策略之外，我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：
（1）定时去清理过期的缓存；
（2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。
两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！
具体用哪种方案，大家可以根据自己的应用场景来权衡。

5.缓存降级

当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。
系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。

降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。

在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：
（1）一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；
（2）警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；
（3）错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；
（4）严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。








